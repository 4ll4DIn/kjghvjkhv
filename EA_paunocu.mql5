//+------------------------------------------------------------------+
//|                                                    EMA_RSI_EA.mq5 |
//|                        Criado por [Seu Nome]                    |
//|             Estratégia de cruzamento de MAs + RSI para fechamento |
//+------------------------------------------------------------------+

#property strict
#include <Trade\Trade.mqh>

//============================= INPUTS ===============================
input double LoteMinimo            = 0.1;  // Tamanho do lote para operação
input int StopLossPontos           = 200;  // Stop loss em pontos
input int TakeProfitPontos         = 400;  // Take profit em pontos
input int TrailingStopGanho        = 300;  // Trailing stop de lucro (em pontos)
input int TrailingStopPerda        = 200;  // Trailing stop de perda (em pontos)
input int BreakEvenBufferPontos    = 20;   // Buffer de Break Even (em pontos)
input int SpreadMaxPontos          = 50;   // Spread máximo permitido

input int MA_Fast_Period           = 9;    // Período da média móvel rápida (EMA)
input int MA_Slow_Period           = 21;   // Período da média móvel lenta (EMA)

input int RSI_Period               = 14;   // Período do RSI
input double RSI_Buy_Level         = 70.0; // Nível de sobrecompra (para fechar venda)
input double RSI_Sell_Level        = 30.0; // Nível de sobrevenda (para fechar compra)

input bool UsarTrailingStop        = true;  // Ativar trailing stop
input bool UsarBreakEven          = true;  // Ativar break even

input bool SalvarLogsArquivo      = true;  // Salvar logs em arquivo .csv
input string NomeArquivoLog       = "EMA_RSI_EA_Logs.csv"; // Nome do arquivo de logs

input bool MarcarEntradasNoGrafico = true; // Marcar entradas no gráfico
input bool MostrarPainel           = true; // Mostrar painel de informações

//========================= VARIÁVEIS GLOBAIS =======================
CTrade trade;                    // Objeto para gerenciamento de ordens

int maFastHandle = INVALID_HANDLE;
int maSlowHandle = INVALID_HANDLE;
int rsiHandle    = INVALID_HANDLE;

datetime lastSignalTime = 0; // Hora do último sinal

ulong totalEntries = 0;      // Total de entradas
ulong totalExits  = 0;       // Total de saídas
double grossProfitSum = 0.0; // Somatório dos lucros
double grossLossSum  = 0.0; // Somatório das perdas

//=========================== FUNCÕES AUXILIARES ====================

double Pt() { return SymbolInfoDouble(_Symbol, SYMBOL_POINT); }

void Log(const string msg) {
   Print(msg);
   if (!SalvarLogsArquivo) return;

   int fileHandle = FileOpen(NomeArquivoLog, FILE_WRITE | FILE_READ | FILE_CSV | FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_TXT, ';');
   if (fileHandle != INVALID_HANDLE) {
      string timestamp = TimeToString(TimeCurrent(), TIME_DATE | TIME_SECONDS);
      FileSeek(fileHandle, 0, SEEK_END);
      FileWrite(fileHandle, timestamp, _Symbol, EnumToString(_Period), msg);
      FileClose(fileHandle);
   }
}

// Verifica se o spread está dentro do limite
bool SpreadOK() {
   double ask = 0, bid = 0;
   if (!SymbolInfoDouble(_Symbol, SYMBOL_ASK, ask) || !SymbolInfoDouble(_Symbol, SYMBOL_BID, bid))
      return false;
   double spread = (ask - bid) / Pt();
   return (spread <= SpreadMaxPontos);
}

// Função para verificar se há uma posição aberta
bool HasOpenPosition(int &pos_dir, double &pos_price, ulong &ticket) {
   pos_dir   = 0;
   pos_price = 0.0;
   ticket    = 0;

   if (!PositionSelect(_Symbol)) return false;
   long type = PositionGetInteger(POSITION_TYPE);
   pos_dir   = (type == POSITION_TYPE_BUY ? 1 : -1);
   pos_price = PositionGetDouble(POSITION_PRICE_OPEN);
   ticket    = PositionGetInteger(POSITION_TICKET);
   return true;
}

// Função para desenhar uma seta no gráfico
void DrawArrow(bool buy, const string tag) {
   if (!MarcarEntradasNoGrafico) return;

   string arrowName = "Signal_" + tag + "_" + IntegerToString((int)TimeCurrent());
   int arrowType = (buy ? DRAW_ARROW : DRAW_ARROW);
   double price = (buy ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK));
   ObjectCreate(0, arrowName, OBJ_ARROW, 0, TimeCurrent(), price);
   ObjectSetInteger(0, arrowName, OBJPROP_COLOR, (buy ? clrLime : clrTomato));
   ObjectSetInteger(0, arrowName, OBJPROP_ARROWCODE, (buy ? 233 : 234));
}

//=========================== INDICADORES ============================
bool CreateIndicators() {
   if (maFastHandle != INVALID_HANDLE) IndicatorRelease(maFastHandle);
   if (maSlowHandle != INVALID_HANDLE) IndicatorRelease(maSlowHandle);
   if (rsiHandle != INVALID_HANDLE) IndicatorRelease(rsiHandle);

   maFastHandle = iMA(_Symbol, PERIOD_CURRENT, MA_Fast_Period, 0, MODE_EMA, PRICE_CLOSE);
   maSlowHandle = iMA(_Symbol, PERIOD_CURRENT, MA_Slow_Period, 0, MODE_EMA, PRICE_CLOSE);
   rsiHandle = iRSI(_Symbol, PERIOD_CURRENT, RSI_Period, PRICE_CLOSE);

   if (maFastHandle == INVALID_HANDLE || maSlowHandle == INVALID_HANDLE || rsiHandle == INVALID_HANDLE) {
      Log("[ERROR] Falha ao criar indicadores.");
      return false;
   }

   return true;
}

// Função para verificar o RSI
bool GetRSI(double &rsi_cur, double &rsi_prev) {
   double buffer[3];
   int copied = CopyBuffer(rsiHandle, 0, 0, 3, buffer);
   if (copied < 3) return false;

   rsi_cur = buffer[0];
   rsi_prev = buffer[1];
   return true;
}

// Função para verificar cruzamento das MAs
bool MA_CrossUp() {
   double fast0, slow0, fast1, slow1;
   if (!GetMAs(fast0, slow0, fast1, slow1)) return false;
   return (fast0 > slow0 && fast1 <= slow1); // Cruzamento de baixo para cima
}

bool MA_CrossDown() {
   double fast0, slow0, fast1, slow1;
   if (!GetMAs(fast0, slow0, fast1, slow1)) return false;
   return (fast0 < slow0 && fast1 >= slow1); // Cruzamento de cima para baixo
}

//========================= POSIÇÕES/ORDENS ==========================
bool OpenBuy() {
   double sl = 0, tp = 0;
   if (StopLossPontos > 0) sl = SymbolInfoDouble(_Symbol, SYMBOL_BID) - StopLossPontos * Pt();
   if (TakeProfitPontos > 0) tp = SymbolInfoDouble(_Symbol, SYMBOL_BID) + TakeProfitPontos * Pt();

   trade.SetExpertMagicNumber(MagicNumber);
   bool ok = trade.Buy(LoteMinimo, _Symbol, 0.0, sl, tp, "Buy Order");
   if (ok) {
      totalEntries++;
      DrawArrow(true, "BUY");
      Log("[ENTRADA] Compra aberta.");
   }
   return ok;
}

bool OpenSell() {
   double sl = 0, tp = 0;
   if (StopLossPontos > 0) sl = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + StopLossPontos * Pt();
   if (TakeProfitPontos > 0) tp = SymbolInfoDouble(_Symbol, SYMBOL_ASK) - TakeProfitPontos * Pt();

   trade.SetExpertMagicNumber(MagicNumber);
   bool ok = trade.Sell(LoteMinimo, _Symbol, 0.0, sl, tp, "Sell Order");
   if (ok) {
      totalEntries++;
      DrawArrow(false, "SELL");
      Log("[ENTRADA] Venda aberta.");
   }
   return ok;
}

//============================== SINAIS ==============================
bool SignalBUY() {
   double rsi_cur, rsi_prev;
   if (!GetRSI(rsi_cur, rsi_prev)) return false;

   bool rsiOK = (rsi_cur >= RSI_Buy_Level); // RSI na zona de compra
   bool maOK  = MA_CrossUp();

   return (rsiOK && maOK);
}

bool SignalSELL() {
   double rsi_cur, rsi_prev;
   if (!GetRSI(rsi_cur, rsi_prev)) return false;

   bool rsiOK = (rsi_cur <= RSI_Sell_Level); // RSI na zona de venda
   bool maOK  = MA_CrossDown();

   return (rsiOK && maOK);
}

//=============================== INIT ================================
int OnInit() {
   Log(StringFormat("[PARAM] RSI(%d) Buy>=%.1f  Sell<=%.1f | MAs %d/%d %s | SL=%d TP=%d",
       RSI_Period, RSI_Buy_Level, RSI_Sell_Level, MA_Fast_Period, MA_Slow_Period, EnumToString(MA_Method), StopLossPontos, TakeProfitPontos));

   if (!CreateIndicators()) return(INIT_FAILED);
   
   trade.SetExpertMagicNumber(MagicNumber);
   Log("[READY] EA pronto.");
   return(INIT_SUCCEEDED);
}

//================================ TICK ===============================
void OnTick() {
   if (!SpreadOK()) return;
   if (!DebounceOK()) return();

   int dir; double price; ulong tk;
   bool hasPos = HasOpenPosition(dir, price, tk);

   bool buySig = SignalBUY();
   bool sellSig = SignalSELL();

   if (!buySig && !sellSig) return;

   lastSignalTime = TimeCurrent();

   // Uma ordem por vez
   if (UmaOrdemPorVez && hasPos) {
      if ((dir > 0 && sellSig) || (dir < 0 && buySig)) {
         trade.PositionClose(tk);
         return;
      }
      return;
   }

   if (buySig) OpenBuy();
   if (sellSig) OpenSell();
}
